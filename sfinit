#!/bin/bash


# Autor Janusz Ładecki <janusz.ladecki@gmail.com>

clear

version=18.3.11
github_url='https://github.com/szunaj13pl/shell-task-runner'
config_folder="$HOME/.config/task-runner"


versionCompare() {
    if [[ $1 == $2 ]]
    then
        return 0
    fi
    local IFS=.
    local i ver1=($1) ver2=($2)
    
    # fill empty fields in ver1 with zeros
    for ((i=${#ver1[@]}; i<${#ver2[@]}; i++))
    do
        ver1[i]=0
    done
    for ((i=0; i<${#ver1[@]}; i++))
    do
        if [[ -z ${ver2[i]} ]]
        then
            # fill empty fields in ver2 with zeros
            ver2[i]=0
        fi
        if ((10#${ver1[i]} > 10#${ver2[i]}))
        then
            
            return 1
        fi
        if ((10#${ver1[i]} < 10#${ver2[i]}))
        then
            
            return 2
        fi
    done
    
    return 0
    
}


function initial(){
    
    scriptName=$(basename $0)
    scriptServerVersion=$(mktemp -d /tmp/$scriptName.XXXXXX)
    script=$(mktemp /tmp/$scriptName.XXXXXX)
    
    # Use colors, but only if connected to a terminal, and that terminal supports them.
    if which tput >/dev/null 2>&1; then
        ncolors=$(tput colors)
    fi
    if [ -t 1 ] && [ -n "$ncolors" ] && [ "$ncolors" -ge 8 ]; then
        RED="$(tput setaf 1)"
        GREEN="$(tput setaf 2)"
        YELLOW="$(tput setaf 3)"
        BLUE="$(tput setaf 4)"
        BOLD="$(tput bold)"
        NORMAL="$(tput sgr0)"
        
        # Define dispaly formats
        AUTHOR_FORMAT=$( tput setab 0; tput setaf 2; )
        DESCRIPTION_FORMAT=$( tput setab 7; tput bold; tput setaf 0; )
        COMMAND_FORMAT=$( tput dim; tput setaf 6; )
        COMMAND2_FORMAT=$( tput sgr0; tput setab 0; tput setaf 2; tput bold; )
        OUTPUT_FORMAT=$( tput sgr0; tput setaf 4; )
        ERR_FORMAT=$( tput sgr0; tput setaf 1; tput bold; )
        INFO_FORMAT=$( tput sgr0; tput setaf 3; tput bold; )
        SCCESS_FORMAT=$( tput sgr0; tput setaf 2; tput bold; )
        CLEAR_FORMAT=$( tput sgr0; )
    else
        RED=""
        GREEN=""
        YELLOW=""
        BLUE=""
        BOLD=""
        NORMAL=""
    fi
    
    
    echo -e ${AUTHOR_FORMAT} "by Janusz Ładecki"; tput cud 3
    
}


function isInstalled(){
    
    local packagesName="$@"
    
    for package in $packagesName; do
        INSTALLED=$(dpkg-query -s "$package" 2>&1 | grep --no-messages Status )
        if [ "$INSTALLED" != "Status: install ok installed" ]; then
            echo -e "${NORMAL} $package ${RED}not installed ${NORMAL}"
            sudo apt-get install -y "$package"
        fi
    done
    
}


function getServerVersion(){
    
    git clone "$github_url" "$scriptServerVersion"
    
}

function refreshDefaultConfigFile(){
    
    cp "${scriptServerVersion}/default_config" "${config_folder}/default_config"\
    && cp "${config_folder}/config" "${config_folder}/config.bak"
    
    if [ ! -s "${config_folder}/config" ]; then
        cp "${config_folder}/default_config" "${config_folder}/config"
    fi
}


function checkConfig(){
    
    if [ ! -s "${config_folder}/config" ]; then
        
        mkdir -p "$config_folder" || echo "Can not create default config at ${config_folder}/config" && echo "Default config was created"
        
        getServerVersion && refreshDefaultConfigFile && getConfig
        
    else
        getConfig
    fi
    
}


function getConfig(){
    source "${config_folder}/config"
    
}


function checkLastUpdateDate(){
    
    if [ "$autoupdate" == true ] || [ ! -z ${just_update+x} ]; then
        
        # Get last update date from config
        local last_update_date=$(cat "${config_folder}/config" | grep --perl-regexp  'last_update_date\=([0-9]{4}\-[0-9]{1,2}\-[0-9]{1,2})' | cut -d "=" -f 2)
        local current_date="$(date +%F)"
        
        if [[ ! "$current_date" == "$last_update_date" ]] || [ "$just_update" == true ]
        then
            echo "Check for update" && checkOnlineVersion
            sed -E -i "s/last_update_date\=([0-9]{4}\-[0-9]{1,2}\-[0-9]{1,2})/last_update_date\=$current_date/" "${config_folder}/config"\
            || echo "Missing 'last_update_date' parameter in ${config_folder}/config"
        fi
        
    else
        
        echo -e "Autoupdate is${RED} OFF ${NORMAL}"
    fi
    
}

function checkOnlineVersion(){
    
    ping -c 2 Github.com 2>>/dev/null 1>&2 || (echo -e "Github.com ${RED} Unrechable ${NORMAL}" && exit 1)
    
    getServerVersion
    
    local server_version=$(cat "${scriptServerVersion}/${scriptName}" | grep --max-count=1 'version' |  cut -d "=" -f 2)
    
    versionCompare $version $server_version && echo -e "${YELLOW} Latest version is instaled ${NORMAL}" || (echo -e "${GREEN} New wersion on GitHub ${NORMAL}" && replaceLocalScript $server_version )
    
}


function replaceLocalScript(){
    
    local online_version="$1"
    local script_full_path=$(which ${scriptName} | head -n 1)
    
    cp "$script_full_path" "${script_full_path}.bak" \
    && cp "${scriptServerVersion}/${scriptName}" $(dirname $script_full_path) \
    && refreshDefaultConfigFile
    
    # Cleaning
    rm -rf "$scriptServerVersion" "${script_full_path}.bak"
    
    # $scriptName && exit 0
    ./"${scriptName}" && exit 0
}


# ==============  TaskRunner  ===============

function defineVariable(){
    # Define custom variable
    if [ ! -z "$variableName" ];then
        eval "$variableName"=true
    fi
    
}


function defineVarOnGrep(){
    
    grep --count "$stringToGrep" "$tmpfile" "$outputFile" >> /dev/null \
    && echo -e ${INFO_FORMAT}"\n\t $messageOnGrep ${CLEAR_FORMAT}\n"\
    && defineVariable "$variableName"
    
}


function setResultBadge(){
    
    local exitCode=$1
    
    if [ "$exitCode" == "SKIP" ]; then
        RESULT="${CLEAR_FORMAT}[${INFO_FORMAT}SKIP${CLEAR_FORMAT}]"
        exitCode=0
        elif [ "$exitCode" -ge 1 ]; then
        RESULT="${CLEAR_FORMAT}[${ERR_FORMAT}FAIL${CLEAR_FORMAT}]"
        echo -e ${ERR_FORMAT} "\n\t Error code $exitCode"
        
        # Define custom variable if Grep is not set
        if [ -z "$stringToGrep" ]; then
            defineVariable "$variableName"
        fi
        
    else
        RESULT="${CLEAR_FORMAT}[${SCCESS_FORMAT}DONE${CLEAR_FORMAT}]"
    fi
    
    # Moves cursor
    tput sc
    tput cuf 80;tput cuu 2; echo -e "$RESULT"
    tput rc
    
}


function defineCommand(){
    
    local verbose=$1
    local dieOnError=$2
    local command="$3"
    local description="$4"
    local variableName="$5"
    local stringToGrep="$6"
    local messageOnGrep="$7"
    local scriptName $(basename $0)
    local tmpfile=$(mktemp /tmp/$scriptName.XXXXXX)
    local outputFile=$(mktemp /tmp/$scriptName.XXXXXX)
    
    if [ $verbose == true ] || [ "$verbose" == "v" ] || [ "$verbose" == "verbose" ]; then
        local VERBOSE=true
    else
        local VERBOSE=false
    fi
    
    echo -e ${DESCRIPTION_FORMAT} "$description" ${CLEAR_FORMAT}
    echo -e ${COMMAND_FORMAT} "$command \n" ${CLEAR_FORMAT}
    
    preExecute "$command" $VERBOSE
    setResultBadge $exitCode
    
    echo -e ${CLEAR_FORMAT}"\n"
    
    rm "$tmpfile" "$outputFile"
    
    # Stop script on error (define)
    if [ "$dieOnError" == "true" ] && [ $exitCode -ge 1 ]; then
        exit $exitCode
    fi
    
}


function executeCommand(){
    
    local COMMAND="$1"
    local VERBOSE=$2
    
    if $VERBOSE
    then
        script --quiet --return --command "$COMMAND" "$tmpfile"; exitCode=$?
    else
        echo -e ${OUTPUT_FORMAT}; script --quiet --return --command "$COMMAND 1> $outputFile" "$tmpfile"; exitCode=$?
        
        # Dispaly Output 1 if err and Output 2 is empty
        if [ -s "$tmpfile" ] && [ $exitCode -ge 1 ];then
            cat "$outputFile"
        fi
    fi
    
    # Call grep function
    if [ ! -z "$stringToGrep" ]; then
        defineVarOnGrep "$stringToGrep"
    fi
    
}


function preExecute(){
    
    local COMMAND="$1"
    local VERBOSE=$2
    
    case "$COMMAND" in
        
        "npm install")
            
            if [ -f package.json ]; then
                executeCommand "$COMMAND" $VERBOSE
            else
                echo -e "\n\t ${ERR_FORMAT}package.json${INFO_FORMAT} not found"
                exitCode=SKIP
            fi
        ;;
        *bin/console*)
            if ! [ -f bin/console ]; then
                echo -e ${INFO_FORMAT}"Change bin/console to app/console"${CLEAR_FORMAT}
                COMMAND=$(echo "$COMMAND" | sed -u 's/bin\/console/app\/console/')
                echo "$COMMAND"
            fi
            
            executeCommand "$COMMAND" $VERBOSE
        ;;
        *)
            executeCommand "$COMMAND" $VERBOSE
        ;;
    esac
    
}



usage() {
    echo "Usage: $(basename $0) [ -c 'edit configuration' ] [ -d 'enable debuging mode' ] [ -u 'self update' ] [ <string> 'to search repository' ]" \
    1>&2; exit 1;
}


while getopts ":dcuvv" o; do
    case "${o}" in
        d)
            echo "Debug mode is ON"
            
            set -x ;
            set -o functrace
        ;;
        c)
            if [ -e "${config_folder}/config" ]; then
                editor "${config_folder}/config"
            else
                checkConfig
                editor "${config_folder}/config"
            fi
            
            exit 0
        ;;
        u)
            just_update=true
        ;;
        v)
            VERBOSE=$(($VERBOSE + 1))
        ;;
        *)
            usage
        ;;
    esac
done
shift $((OPTIND-1))

PROJECT_SEARCH_PARAM="$1"



# set -x

# Defines variables and create temp files
initial

# Install requierd programs
isInstalled git wget

# Check for new update
checkLastUpdateDate

[ "$just_update" == true ] && exit 0

# Get config
checkConfig

# Run tasks
run

# set +x